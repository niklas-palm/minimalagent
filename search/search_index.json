{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MinimalAgent Documentation","text":"<p>A lightweight agent framework for Amazon Bedrock designed for simplicity and extensibility.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83e\udde0 Reasoning - Clear tracking of agent's thinking steps</li> <li>\ud83d\udee0\ufe0f Tools - Simple decorator-based tool definition</li> <li>\ud83d\udcbe Sessions - Built-in persistent memory with Amazon DynamoDB</li> <li>\ud83d\udcbb Display - Rich, colorful reasoning display</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install minimalagent\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from minimalagent import Agent, tool\n\n@tool\ndef add(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers.\n\n    Args:\n        a: First number\n        b: Second number\n\n    Returns:\n        Sum of the two numbers\n    \"\"\"\n    return a + b\n\nagent = Agent(tools=[add])\nresponse, reasoning = agent.run(\"What is 5 + 3?\")\nprint(f\"Response: {response}\")\nprint(f\"Steps taken: {reasoning.total_steps}\")\n</code></pre>"},{"location":"#project-goals","title":"Project Goals","text":"<p>MinimalAgent was created with these goals in mind:</p> <ol> <li>Simplicity - Minimal boilerplate to get started</li> <li>Transparency - Clear visibility into the agent's reasoning process</li> <li>Extensibility - Easy to add custom tools and capabilities</li> <li>Performance - Lightweight implementation with minimal dependencies</li> </ol>"},{"location":"#production-considerations","title":"Production Considerations","text":"<p>MinimalAgent is essentially a wrapper over the Bedrock Covnerse API (with optional session management using DDB), making it a simple framework for quickly bootstrapping AWS-native agents. It currently lacks integration with observability tools like Langfuse, so for large-scale production deployments I encourage you to use another framework.</p> <p>For large-scale production deployments that require enterprise-grade observability, reliability, and scaling capabilities, Amazon Bedrock Agents might be a more suitable alternative.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>Info</p> <p>This page mirrors the project's main CHANGELOG.md file.</p>"},{"location":"changelog/#027-2025-05-14","title":"[0.2.7] - 2025-05-14","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Added <code>py.typed</code> marker file to enable proper type hints in IDEs</li> </ul>"},{"location":"changelog/#026-2025-05-13","title":"[0.2.6] - 2025-05-13","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Removed problematic docstring_tools_example.py due to persistent API compatibility issues</li> <li>Removed unused 'requests' dependency</li> </ul>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Added missing Tool API Reference documentation in docs/api/tool.md</li> <li>Updated mkdocs.yml navigation to include Tool API documentation</li> </ul>"},{"location":"changelog/#024-2025-05-13","title":"[0.2.4] - 2025-05-13","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Improved documentation clarity about production readiness</li> <li>Added clear statements about AWS-native integration in README and docs</li> <li>Clarified that MinimalAgent is essentially a wrapper over Bedrock Converse API</li> <li>Added note about lack of integration with observability tools like Langfuse</li> <li>Updated docs to suggest alternative frameworks for large-scale production use</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fixed AttributeError in reasoning_example.py</li> <li>Updated code to use direct attribute access on Reasoning objects instead of dictionary-style access</li> <li>Changed all instances of .get() method calls to direct attribute access</li> <li>Ensures proper access to Reasoning data class properties</li> </ul>"},{"location":"changelog/#023-2025-05-13","title":"[0.2.3] - 2025-05-13","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Significantly improved documentation for enhanced developer experience</li> <li>Simplified data models documentation to focus on practical usage</li> <li>Restructured logging documentation for better clarity</li> <li>Enhanced README with clearer reasoning display examples</li> <li>Improved configuration reference with detailed parameter validation and dependencies</li> </ul>"},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Added \"Bring Your Own DynamoDB Table\" section with CloudFormation example</li> <li>Added comprehensive parameter reference with validation rules</li> <li>Added example code for analyzing tool usage in sessions</li> </ul>"},{"location":"changelog/#022-2025-05-12","title":"[0.2.2] - 2025-05-12","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fixed duplicate message issue in conversation history</li> <li>Removed duplicate assistant message append before saving to DynamoDB</li> <li>Prevents both duplicate messages in the array and self-repeating content in responses</li> </ul>"},{"location":"changelog/#021-2025-05-12","title":"[0.2.1] - 2025-05-12","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed session message retrieval to consistently get the most recent conversation history</li> <li>Changed <code>get_session_messages</code> query to sort by timestamp descending (newest first)</li> <li>Added limit to only fetch the most recent message item</li> </ul>"},{"location":"changelog/#020-2025-05-12","title":"[0.2.0] - 2025-05-12","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>BREAKING CHANGE: Updated DynamoDB table schema to use standard single-table design</li> <li>Changed <code>session_id</code> attribute to <code>pk</code> (partition key)</li> <li>Changed <code>timestamp</code> attribute to <code>sk</code> (sort key)</li> <li>All existing tables will need to be recreated with the new schema</li> <li>Changed default log level from ERROR to WARNING to align with Python logging standards</li> <li>Improved DynamoDB size limit handling to be more robust and user-friendly</li> <li>Changed from preemptive size checking to exception-based handling</li> <li>Added explicit warning to final response when size limit is exceeded</li> <li>Now keeps full reasoning data until a size exception is encountered</li> </ul>"},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Enhanced DynamoDB documentation with comprehensive table structure details</li> <li>More detailed explanations of single-table design pattern in README</li> <li>Added additional tests for real-time reasoning functionality</li> <li>Added comprehensive table showing entity types and their attributes</li> <li>Added new <code>log_level</code> parameter to control standard logging verbosity</li> <li>Completely redesigned logging system with separate pathways for:</li> <li>Standard logging (errors, warnings) using Python's logging module</li> <li>Colorized reasoning display for interactive use (controlled by show_reasoning)</li> <li>Added debug logging for all major agent operations</li> <li>Improved error logging to always log errors regardless of <code>show_reasoning</code> setting</li> <li>Enhanced display methods with more distinct color coding and better formatting</li> <li>Added <code>exceeded_size_limit</code> flag to Reasoning model to indicate when data was truncated</li> <li>Added special formatting for info messages to distinguish them from other output</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Improved test coverage for real_time_reasoning feature</li> <li>Fixed duplicate log entries by setting logger.propagate=False</li> <li>Fixed plain text info messages by adding proper color formatting</li> </ul>"},{"location":"changelog/#010-2025-05-10","title":"[0.1.0] - 2025-05-10","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Initial release of MinimalAgent</li> <li>Core Agent class with Amazon Bedrock integration</li> <li>Tool decorator with automatic docstring parsing</li> <li>Session memory support via DynamoDB</li> <li>Configurable reasoning display with color formatting</li> <li>Dynamic tool management (add/remove tools at runtime)</li> <li>Support for system prompts</li> <li>Error handling for AWS credentials</li> <li>Multiple example scripts</li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li>Session ID validation to prevent injection attacks</li> <li>DynamoDB TTL for automatic data expiration</li> </ul>"},{"location":"contributing/","title":"Contributing to MinimalAgent","text":"<p>We're thrilled that you're interested in contributing to MinimalAgent! This document provides guidelines and instructions for contributing to the project.</p>"},{"location":"contributing/#setting-up-development-environment","title":"Setting Up Development Environment","text":"<ol> <li> <p>Fork and clone the repository:    <pre><code>git clone https://github.com/yourusername/minimalagent.git\ncd minimalagent\n</code></pre></p> </li> <li> <p>Create a virtual environment:    <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>Install development dependencies:    <pre><code>pip install -e \".[dev]\"\n</code></pre></p> </li> </ol>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<p>We use pytest for testing. Run the tests with:</p> <pre><code>pytest\n</code></pre> <p>For test coverage:</p> <pre><code>pytest --cov=src/minimalagent tests/\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We follow PEP 8 style guidelines. We use Black for code formatting and isort for import sorting:</p> <pre><code>black src tests\nisort src tests\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li> <p>Create a branch for your feature:    <pre><code>git checkout -b feature/my-feature\n</code></pre></p> </li> <li> <p>Make your changes:</p> </li> <li>Write code following the style guidelines</li> <li>Add tests for new functionality</li> <li> <p>Update documentation as needed</p> </li> <li> <p>Ensure tests pass:    <pre><code>pytest\n</code></pre></p> </li> <li> <p>Submit a pull request:</p> </li> <li>Provide a clear description of the changes</li> <li>Reference any issues that the PR addresses</li> <li>Make sure CI checks pass</li> </ol>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Documentation is crucial - please update docs when adding or changing features:</p> <ul> <li>Update docstrings for any modified functions/classes</li> <li>Update README.md if appropriate</li> <li>Update CHANGELOG.md with your changes</li> <li>For significant changes, add/update the appropriate documentation pages</li> </ul> <p>To preview documentation changes:</p> <pre><code>mkdocs serve\n</code></pre> <p>Then visit http://localhost:8000 in your browser.</p>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>When reporting issues, please include:</p> <ul> <li>A clear and descriptive title</li> <li>Steps to reproduce the issue</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>System information (Python version, OS, etc.)</li> <li>If possible, a minimal code example demonstrating the issue</li> </ul>"},{"location":"contributing/#feature-requests","title":"Feature Requests","text":"<p>We welcome feature requests! When submitting:</p> <ul> <li>Describe the feature in detail</li> <li>Explain why it would be valuable</li> <li>Provide examples of how it would be used</li> <li>Indicate if you're willing to help implement it</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the project's MIT License.</p>"},{"location":"getting-started/","title":"Getting Started with MinimalAgent","text":"<p>This guide will help you quickly build an agentic application using MinimalAgent and Amazon Bedrock.</p> <p>MinimalAgent is essentially a wrapper over the Bedrock Covnerse API (with optional session management using DDB), making it a simple framework for quickly bootstrapping AWS-native agents. It currently lacks integration with observability tools like Langfuse, so for large-scale production deployments I encourage you to use another framework.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install minimalagent\n</code></pre> <p>Tip</p> <p>Make sure you have Python 3.8 or newer installed.</p>"},{"location":"getting-started/#1-create-your-first-agent","title":"1. Create Your First Agent","text":"<p>Let's create a simple agent that can retrieve weather information:</p> <pre><code>from minimalagent import Agent, tool\n\n# Define a tool\n@tool\ndef get_weather(location: str) -&gt; dict:\n    \"\"\"Get current weather conditions.\n\n    Args:\n        location: City name to get weather for\n\n    Returns:\n        Weather information dictionary\n    \"\"\"\n    # In a real app, you would call a weather API\n    return {\n        \"temperature\": 72,\n        \"condition\": \"sunny\",\n        \"humidity\": \"45%\",\n        \"location\": location\n    }\n\n# Create and run the agent\nagent = Agent(tools=[get_weather])\nresponse, reasoning = agent.run(\"What's the weather in Tokyo?\")\n\nprint(response)\n</code></pre>"},{"location":"getting-started/#2-add-multiple-tools","title":"2. Add Multiple Tools","text":"<p>Agents become more powerful when they have multiple tools available:</p> <pre><code>@tool\ndef search_wiki(query: str, max_results: int = 3) -&gt; list:\n    \"\"\"Search Wikipedia for information.\n\n    Args:\n        query: Search terms\n        max_results: Maximum number of results to return\n\n    Returns:\n        List of search results\n    \"\"\"\n    # Simulate search results\n    return [\n        {\"title\": f\"Result for {query}\", \"snippet\": f\"Information about {query}...\"},\n        {\"title\": f\"Another result for {query}\", \"snippet\": \"More information...\"}\n    ][:max_results]\n\n@tool\ndef calculate(expression: str) -&gt; dict:\n    \"\"\"Calculate a mathematical expression.\n\n    Args:\n        expression: The math expression to evaluate\n\n    Returns:\n        Result of the calculation\n    \"\"\"\n    try:\n        result = eval(expression)\n        return {\"result\": result, \"expression\": expression}\n    except Exception as e:\n        return {\"error\": str(e), \"expression\": expression}\n\n# Create agent with multiple tools\nagent = Agent(\n    tools=[get_weather, search_wiki, calculate],\n    show_reasoning=True  # Show reasoning process in the terminal\n)\n</code></pre>"},{"location":"getting-started/#3-enable-session-memory","title":"3. Enable Session Memory","text":"<p>Add memory to your agent so it can remember previous interactions:</p> <pre><code># Create agent with session support\nagent = Agent(\n    tools=[get_weather, search_wiki, calculate],\n    use_session_memory=True  # Enable persistent memory\n)\n\n# First interaction\nresponse1, _ = agent.run(\n    \"What's the weather in Seattle?\",\n    session_id=\"user123\"  # Unique identifier for this conversation\n)\n\n# Follow-up question (agent will remember previous context)\nresponse2, _ = agent.run(\n    \"How about in Portland?\",\n    session_id=\"user123\"  # Same session ID connects the conversations\n)\n</code></pre>"},{"location":"getting-started/#4-customize-agent-behavior","title":"4. Customize Agent Behavior","text":"<p>Adjust the agent's capabilities and behavior:</p> <pre><code>agent = Agent(\n    # Tool configuration\n    tools=[get_weather, search_wiki],\n    max_steps=10,  # Allow more tool use iterations for complex tasks\n\n    # Display configuration\n    show_reasoning=True,  # Show colorized reasoning in terminal\n    log_level=\"INFO\",  # More detailed logging (DEBUG, INFO, WARNING, ERROR)\n\n    # Model configuration\n    model_id=\"us.amazon.nova-pro-v1:0\",  # Specify Bedrock model\n    system_prompt=\"You are a helpful weather assistant that provides accurate forecasts.\",\n\n    # Session configuration\n    use_session_memory=True,\n    session_ttl=7200,  # 2-hour session timeout\n)\n</code></pre>"},{"location":"getting-started/#5-access-reasoning-information","title":"5. Access Reasoning Information","text":"<p>See how the agent thinks and uses tools:</p> <pre><code>response, reasoning = agent.run(\"What's the temperature in Paris and London?\")\n\n# Display reasoning process\nprint(f\"Query: {reasoning.query}\")\nprint(f\"Steps: {reasoning.total_steps}\")\n\nfor step in reasoning.steps:\n    print(f\"\\nStep {step.step_number} thinking:\")\n    print(step.thinking)\n\n    for tool in step.tools:\n        print(f\"Tool: {tool.name}\")\n        print(f\"Inputs: {tool.inputs}\")\n        print(f\"Result: {tool.result}\")\n\nprint(f\"\\nFinal response: {reasoning.final_response}\")\n</code></pre>"},{"location":"getting-started/#6-put-it-all-together","title":"6. Put It All Together","text":"<p>Here's a complete example showing the main features:</p> <pre><code>from minimalagent import Agent, tool\n\n@tool\ndef get_weather(location: str) -&gt; dict:\n    \"\"\"Get weather information for a location.\"\"\"\n    # Simulate weather data\n    return {\"temperature\": 75, \"condition\": \"sunny\", \"location\": location}\n\n@tool\ndef convert_temperature(celsius: float) -&gt; dict:\n    \"\"\"Convert Celsius to Fahrenheit.\"\"\"\n    fahrenheit = (celsius * 9/5) + 32\n    return {\"celsius\": celsius, \"fahrenheit\": fahrenheit}\n\n# Create agent\nagent = Agent(\n    tools=[get_weather, convert_temperature],\n    use_session_memory=True,\n    show_reasoning=True,\n    system_prompt=\"You are a helpful weather assistant.\"\n)\n\n# Run queries in a session\nsession_id = \"weather-session-1\"\n\n# First query\nresponse1, reasoning1 = agent.run(\n    \"What's the weather in Paris?\",\n    session_id=session_id\n)\nprint(f\"Response: {response1}\")\n\n# Follow-up query\nresponse2, reasoning2 = agent.run(\n    \"Convert that temperature to Fahrenheit.\",\n    session_id=session_id\n)\nprint(f\"Response: {response2}\")\n\n# Get reasoning history to see all interactions\nhistory = agent.get_reasoning_history(session_id)\nprint(f\"Session has {len(history)} interactions\")\n</code></pre>"},{"location":"getting-started/#aws-credentials","title":"AWS Credentials","text":"<p>MinimalAgent uses Amazon Bedrock, so you'll need to set up AWS credentials:</p> <ol> <li>Configure credentials using the AWS CLI: <code>aws configure</code></li> <li>Or set environment variables:</li> </ol> <pre><code>export AWS_ACCESS_KEY_ID=your_access_key\nexport AWS_SECRET_ACCESS_KEY=your_secret_key\nexport AWS_REGION=us-west-2\n</code></pre> <p>Permissions Required</p> <p>Ensure your AWS credentials have permissions to access the Amazon Bedrock service.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the Tool Creation Guide to build more powerful tools</li> <li>Learn about Session Management for persistent conversations</li> <li>Customize the Reasoning Display for better visibility</li> <li>Understand Reasoning Data for analyzing agent behavior</li> <li>Check out the API Reference for detailed documentation</li> </ul>"},{"location":"examples/basic/","title":"Basic Usage Examples","text":"<p>These examples demonstrate common patterns for using MinimalAgent.</p>"},{"location":"examples/basic/#simple-tool-invocation","title":"Simple Tool Invocation","text":"<pre><code>from minimalagent import Agent, tool\n\n@tool\ndef calculate(expression: str) -&gt; dict:\n    \"\"\"Calculate the result of a mathematical expression.\n\n    Args:\n        expression: A mathematical expression as a string\n\n    Returns:\n        Dictionary with the result\n    \"\"\"\n    try:\n        # Be careful with eval in production code!\n        result = eval(expression)\n        return {\"result\": result}\n    except Exception as e:\n        return {\"error\": str(e)}\n\n# Initialize the agent\nagent = Agent(tools=[calculate], show_reasoning=True)\n\n# Run a calculation\nresponse, reasoning = agent.run(\"What is 15 * 7 + 22?\")\n\n# Print the response\nprint(f\"\\nFinal response: {response}\")\n</code></pre>"},{"location":"examples/basic/#multiple-tools","title":"Multiple Tools","text":"<pre><code>from minimalagent import Agent, tool\nimport random\n\n@tool\ndef roll_dice(sides: int = 6, count: int = 1) -&gt; dict:\n    \"\"\"Roll dice with the specified number of sides.\n\n    Args:\n        sides: Number of sides on each die\n        count: Number of dice to roll\n\n    Returns:\n        Dictionary with the results\n    \"\"\"\n    results = [random.randint(1, sides) for _ in range(count)]\n    return {\n        \"results\": results,\n        \"total\": sum(results),\n        \"sides\": sides,\n        \"count\": count\n    }\n\n@tool\ndef flip_coin(count: int = 1) -&gt; dict:\n    \"\"\"Flip a coin one or more times.\n\n    Args:\n        count: Number of coins to flip\n\n    Returns:\n        Dictionary with the results\n    \"\"\"\n    results = [random.choice([\"heads\", \"tails\"]) for _ in range(count)]\n    return {\n        \"results\": results,\n        \"count\": count,\n        \"heads\": results.count(\"heads\"),\n        \"tails\": results.count(\"tails\")\n    }\n\n# Initialize the agent with multiple tools\nagent = Agent(tools=[roll_dice, flip_coin])\n\n# Run a query that might use either tool\nresponse, reasoning = agent.run(\"Roll 3 dice with 20 sides each\")\nprint(f\"Response: {response}\")\n\n# Run another query for the other tool\nresponse, reasoning = agent.run(\"Flip 5 coins and tell me how many heads I got\")\nprint(f\"Response: {response}\")\n</code></pre>"},{"location":"examples/basic/#custom-system-prompt","title":"Custom System Prompt","text":"<pre><code>from minimalagent import Agent, tool\n\n@tool\ndef get_capital(country: str) -&gt; dict:\n    \"\"\"Get the capital city of a country.\n\n    Args:\n        country: Name of the country\n\n    Returns:\n        Dictionary with country and capital\n    \"\"\"\n    # In a real application, you would look this up in a database\n    capitals = {\n        \"france\": \"Paris\",\n        \"japan\": \"Tokyo\",\n        \"australia\": \"Canberra\",\n        \"brazil\": \"Bras\u00edlia\",\n        \"egypt\": \"Cairo\"\n    }\n\n    country_lower = country.lower()\n    if country_lower in capitals:\n        return {\"country\": country, \"capital\": capitals[country_lower]}\n    else:\n        return {\"country\": country, \"error\": \"Country not found in database\"}\n\n# Custom system prompt to guide the agent's behavior\nsystem_prompt = \"\"\"\nYou are a geography expert specializing in capital cities.\nAlways use formal language and provide brief educational facts about capitals when possible.\n\"\"\"\n\n# Initialize the agent with the custom system prompt\nagent = Agent(\n    tools=[get_capital],\n    system_prompt=system_prompt\n)\n\n# Run a query\nresponse, reasoning = agent.run(\"What is the capital of Japan?\")\nprint(response)\n</code></pre>"},{"location":"examples/basic/#error-handling","title":"Error Handling","text":"<pre><code>from minimalagent import Agent, tool\n\n@tool\ndef divide(a: float, b: float) -&gt; dict:\n    \"\"\"Divide two numbers.\n\n    Args:\n        a: Numerator\n        b: Denominator\n\n    Returns:\n        Dictionary with the result\n    \"\"\"\n    try:\n        if b == 0:\n            return {\"error\": \"Cannot divide by zero\"}\n        return {\"result\": a / b}\n    except Exception as e:\n        return {\"error\": str(e)}\n\n# Initialize the agent\nagent = Agent(tools=[divide])\n\n# Run a valid query\nresponse, reasoning = agent.run(\"What is 10 divided by 2?\")\nprint(f\"Valid division: {response}\")\n\n# Run a query that will trigger an error\nresponse, reasoning = agent.run(\"What is 10 divided by 0?\")\nprint(f\"Division by zero: {response}\")\n</code></pre>"},{"location":"guide/configuration/","title":"Configuration Options","text":"<p>MinimalAgent provides numerous configuration options to tailor the agent's behavior to your specific needs. This comprehensive guide covers all available configuration settings.</p>"},{"location":"guide/configuration/#agent-configuration","title":"Agent Configuration","text":"<p>When creating an agent, you can provide various configuration parameters:</p> <pre><code>from minimalagent import Agent\n\nagent = Agent(\n    # Tool configuration\n    tools=[tool1, tool2],                  # List of tools available to the agent\n    max_steps=5,                          # Maximum number of tool invocation steps\n\n    # Model configuration\n    model_id=\"us.amazon.nova-pro-v1:0\",   # Amazon Bedrock model ID\n    bedrock_region=\"us-west-2\",           # AWS region for Bedrock\n    system_prompt=\"You are a helpful...\",  # Custom system prompt\n\n    # Display and logging\n    show_reasoning=True,                  # Display reasoning in terminal\n    log_level=\"INFO\",                     # Logging verbosity\n\n    # Session configuration\n    use_session_memory=True,              # Enable session persistence\n    session_table_name=\"my-agent-table\",  # DynamoDB table name\n    memory_region=\"us-east-1\",            # AWS region for DynamoDB\n    session_ttl=3600,                     # Session TTL in seconds (1 hour)\n    real_time_reasoning=True,             # Enable real-time reasoning updates\n)\n</code></pre>"},{"location":"guide/configuration/#complete-parameter-reference","title":"Complete Parameter Reference","text":"<p>This table provides detailed information about all available parameters, their defaults, validation rules, and descriptions:</p> Parameter Type Default Validation Description Tool Configuration <code>tools</code> <code>List[Callable]</code> <code>None</code> Must be decorated with <code>@tool</code> List of tool functions available to the agent <code>max_steps</code> <code>int</code> <code>5</code> Must be &gt; 0 Maximum number of tool use iterations Model Configuration <code>model_id</code> <code>str</code> <code>\"us.amazon.nova-pro-v1:0\"</code> Must be a valid Bedrock model Amazon Bedrock model ID <code>bedrock_region</code> <code>str</code> <code>\"us-west-2\"</code> Valid AWS region AWS region for Bedrock <code>system_prompt</code> <code>str</code> <code>\"\"</code> None Custom instructions for the model Display and Logging <code>show_reasoning</code> <code>bool</code> <code>True</code> None Show colorized reasoning in terminal <code>log_level</code> <code>str</code> <code>\"WARNING\"</code> Must be one of: \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\" Controls logging verbosity Session Configuration <code>use_session_memory</code> <code>bool</code> <code>False</code> None Enable persistent sessions with DynamoDB <code>session_table_name</code> <code>str</code> <code>\"minimalagent-session-table\"</code> 3-255 chars, alphanumeric plus hyphens, dots, underscores DynamoDB table name <code>memory_region</code> <code>str</code> Same as <code>bedrock_region</code> Valid AWS region AWS region for DynamoDB <code>session_ttl</code> <code>int</code> <code>3600</code> (1 hour) Must be &gt; 0 Session expiration in seconds <code>real_time_reasoning</code> <code>bool</code> <code>False</code> Requires <code>use_session_memory=True</code> Update reasoning during execution"},{"location":"guide/configuration/#parameter-interactions-and-dependencies","title":"Parameter Interactions and Dependencies","text":"<p>Some parameters have special behaviors or dependencies:</p> <ul> <li><code>memory_region</code>: If not specified, defaults to the same value as <code>bedrock_region</code></li> <li><code>real_time_reasoning</code>: Only works when <code>use_session_memory=True</code></li> <li><code>session_table_name</code>: If a custom name is provided, <code>use_session_memory</code> is automatically enabled</li> <li><code>show_reasoning</code>: Controls visual display only; reasoning data is always returned by the <code>run()</code> method</li> </ul>"},{"location":"guide/configuration/#parameter-validation","title":"Parameter Validation","text":"<p>MinimalAgent validates all parameters at initialization:</p> <pre><code># This will raise an error\nagent = Agent(\n    max_steps=-1,  # Error: max_steps must be greater than 0\n    log_level=\"VERBOSE\",  # Error: invalid log level\n    session_ttl=0  # Error: session_ttl must be greater than 0\n)\n</code></pre> <p>If any validation fails, a <code>ValueError</code> will be raised with a descriptive error message.</p>"},{"location":"guide/configuration/#aws-configuration","title":"AWS Configuration","text":""},{"location":"guide/configuration/#credentials-and-regions","title":"Credentials and Regions","text":"<p>MinimalAgent uses boto3 for AWS interactions. Configure credentials:</p> <pre><code># Using environment variables (recommended)\n# AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION\nimport os\nos.environ[\"AWS_ACCESS_KEY_ID\"] = \"YOUR_ACCESS_KEY\"\nos.environ[\"AWS_SECRET_ACCESS_KEY\"] = \"YOUR_SECRET_KEY\"\nos.environ[\"AWS_REGION\"] = \"us-west-2\"\n\n# Using AWS CLI configuration\n# Run 'aws configure' before starting your application\n</code></pre>"},{"location":"guide/configuration/#configuration-precedence","title":"Configuration Precedence","text":"<p>When multiple configuration methods are used, MinimalAgent follows this precedence (highest to lowest):</p> <ol> <li>Environment variables</li> <li>Default AWS credential discovery</li> <li>Default parameter values</li> </ol>"},{"location":"guide/configuration/#system-prompt-configuration","title":"System Prompt Configuration","text":"<p>The system prompt controls the agent's behavior and personality:</p> <pre><code># Expert mode system prompt\nexpert_prompt = \"\"\"\nYou are an expert data scientist with extensive knowledge of statistical analysis and machine learning.\nAlways provide detailed, technical explanations with references to relevant statistical methods or algorithms.\n\"\"\"\n\nagent = Agent(\n    tools=[...],\n    system_prompt=expert_prompt\n)\n</code></pre> <p>Tip</p> <p>Keep system prompts concise and specific to avoid overwhelming the model with instructions.</p>"},{"location":"guide/configuration/#dynamic-configuration","title":"Dynamic Configuration","text":"<p>Some parameters can be reconfigured after agent creation:</p> <pre><code># Create agent with initial configuration\nagent = Agent(tools=[tool1, tool2])\n\n# Add more tools later\nagent.add_tools([tool3, tool4])\n\n# Update max steps\nagent.max_steps = 15\n</code></pre>"},{"location":"guide/configuration/#environment-variables","title":"Environment Variables","text":"<p>MinimalAgent respects these environment variables:</p> <pre><code># AWS Credentials\nexport AWS_ACCESS_KEY_ID=\"your_access_key\"\nexport AWS_SECRET_ACCESS_KEY=\"your_secret_key\"\nexport AWS_REGION=\"us-west-2\"\n</code></pre>"},{"location":"guide/configuration/#complete-configuration-example","title":"Complete Configuration Example","text":"<pre><code>from minimalagent import Agent, tool\nimport logging\n\n# Setup custom logger\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    filename=\"agent.log\"\n)\nlogger = logging.getLogger(\"agent_logger\")\n\n# Define a tool\n@tool\ndef search(query: str) -&gt; dict:\n    \"\"\"Search for information.\"\"\"\n    return {\"results\": [f\"Result for {query}\"]}\n\n# Create agent with comprehensive configuration\nagent = Agent(\n    # Tool configuration\n    tools=[search],\n    system_prompt=\"You are a helpful search assistant.\",\n    max_steps=8,\n\n    # Model configuration\n    model_id=\"us.amazon.nova-pro-v1:0\",\n    bedrock_region=\"us-west-2\",\n\n    # Display and logging\n    show_reasoning=True,\n    log_level=\"INFO\",\n\n    # Session configuration\n    use_session_memory=True,\n    session_table_name=\"search-agent-sessions\",\n    memory_region=\"us-west-2\",\n    session_ttl=3600,  # 1 hour\n    real_time_reasoning=True,\n)\n\n# Run a query\nresponse, reasoning = agent.run(\n    \"Find information about machine learning\",\n    session_id=\"user-session-123\"\n)\n</code></pre>"},{"location":"guide/configuration/#configuration-best-practices","title":"Configuration Best Practices","text":"<ol> <li>Start Simple: Begin with minimal configuration and add options as needed</li> <li>Match Resources: Adjust <code>max_steps</code> based on task complexity</li> <li>Secure Credentials: Use environment variables rather than hardcoded credentials</li> <li>Test Thoroughly: Create a testing environment with local DynamoDB before production</li> <li>Monitor Usage: Watch your AWS usage, especially with real-time reasoning enabled</li> <li>Optimize TTL: Set session TTL appropriate for your application's conversation patterns</li> </ol>"},{"location":"guide/logging/","title":"Reasoning Display and Logging","text":"<p>MinimalAgent provides visibility into the agent's thinking process through both visual output and programmatic access to reasoning data.</p>"},{"location":"guide/logging/#visual-reasoning-display","title":"Visual Reasoning Display","text":"<p>The agent can display its reasoning process directly in the terminal:</p> <pre><code>from minimalagent import Agent, tool\n\n@tool\ndef search(query: str) -&gt; dict:\n    \"\"\"Search for information.\"\"\"\n    return {\"results\": f\"Results for {query}\"}\n\n# By default, colorized reasoning is shown in the terminal\nagent = Agent(tools=[search])\nresponse, reasoning = agent.run(\"Find information about machine learning\")\n</code></pre> <p>The display includes: - The original query - Each thinking step - Tools being used with their inputs - Tool results - The final response</p> <p>This makes it easy to understand how the agent reached its conclusion and which tools it used.</p>"},{"location":"guide/logging/#controlling-the-display","title":"Controlling the Display","text":"<p>You can enable or disable the colorized reasoning display:</p> <pre><code># Enable reasoning display (default)\nagent = Agent(\n    tools=[search],\n    show_reasoning=True\n)\n\n# Disable reasoning display for production\nagent = Agent(\n    tools=[search],\n    show_reasoning=False\n)\n</code></pre>"},{"location":"guide/logging/#accessing-reasoning-data-programmatically","title":"Accessing Reasoning Data Programmatically","text":"<p>Even when visual display is disabled, you can access the complete reasoning data:</p> <pre><code># Disable visual display but still capture reasoning data\nagent = Agent(tools=[search], show_reasoning=False)\nresponse, reasoning = agent.run(\"Search for quantum computing\")\n\n# Access reasoning data programmatically\nprint(f\"Query: {reasoning.query}\")\nprint(f\"Steps taken: {reasoning.total_steps}\")\n\n# Examine each step\nfor step in reasoning.steps:\n    print(f\"Step {step.step_number} thinking: {step.thinking}\")\n\n    # Examine tools used\n    for tool in step.tools:\n        print(f\"Tool: {tool.name}\")\n        print(f\"Inputs: {tool.inputs}\")\n        print(f\"Result: {tool.result}\")\n</code></pre> <p>This allows you to build your own visualizations or analytics on top of the reasoning data.</p>"},{"location":"guide/logging/#agent-log-levels","title":"Agent Log Levels","text":"<p>The agent's log level controls what information is logged during operation:</p> <pre><code># Minimal logging (warnings and errors only)\nagent = Agent(\n    tools=[search],\n    log_level=\"WARNING\"  # Default\n)\n\n# Informational logs (good for general use)\nagent = Agent(\n    tools=[search],\n    log_level=\"INFO\"\n)\n\n# Verbose debugging (most detailed)\nagent = Agent(\n    tools=[search],\n    log_level=\"DEBUG\"\n)\n</code></pre> <p>Available log levels from least to most verbose: - <code>\"CRITICAL\"</code> - Only critical errors - <code>\"ERROR\"</code> - Error messages - <code>\"WARNING\"</code> - Warnings and errors (default) - <code>\"INFO\"</code> - General information plus warnings and errors - <code>\"DEBUG\"</code> - Detailed debug information plus everything above</p>"},{"location":"guide/logging/#common-logging-scenarios","title":"Common Logging Scenarios","text":""},{"location":"guide/logging/#developmentdebugging","title":"Development/Debugging","text":"<p>For maximum visibility during development:</p> <pre><code>agent = Agent(\n    tools=[search],\n    show_reasoning=True,  # See colorized reasoning\n    log_level=\"DEBUG\"     # Maximum logging detail\n)\n</code></pre>"},{"location":"guide/logging/#production","title":"Production","text":"<p>For production environments:</p> <pre><code>agent = Agent(\n    tools=[search],\n    show_reasoning=False,  # No visual display\n    log_level=\"WARNING\"    # Only important warnings and errors\n)\n</code></pre>"},{"location":"guide/logging/#monitoring","title":"Monitoring","text":"<p>For monitoring in production while maintaining some visibility:</p> <pre><code>agent = Agent(\n    tools=[search],\n    show_reasoning=False,  # No visual display\n    log_level=\"INFO\"       # Information about operations, warnings, and errors\n)\n</code></pre>"},{"location":"guide/logging/#advanced-integration-with-python-logging","title":"Advanced: Integration with Python Logging","text":"<p>MinimalAgent integrates with Python's standard logging system, allowing you to capture logs in your application's logging infrastructure:</p> <pre><code>import logging\n\n# Configure Python's logging system\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    filename=\"agent.log\"  # Save to a file instead of console\n)\n\n# MinimalAgent will use this logging configuration\nagent = Agent(\n    tools=[search],\n    log_level=\"INFO\",  # This level applies to MinimalAgent's logger\n)\n</code></pre> <p>This is useful for: - Saving logs to files instead of the console - Integrating with existing logging infrastructure - Custom log formatting - Log rotation and management</p>"},{"location":"guide/models/","title":"Understanding Reasoning Data","text":"<p>When you run an agent using MinimalAgent, you get back both the text response and a <code>reasoning</code> object containing detailed information about the agent's process. This guide explains the key data structures you'll work with.</p>"},{"location":"guide/models/#the-reasoning-object","title":"The Reasoning Object","text":"<p>The <code>reasoning</code> object gives you access to everything that happened during the agent's execution:</p> <pre><code>from minimalagent import Agent, tool\n\n@tool\ndef calculate(expression: str) -&gt; dict:\n    \"\"\"Calculate a math expression.\"\"\"\n    result = eval(expression)\n    return {\"result\": result}\n\nagent = Agent(tools=[calculate])\nresponse, reasoning = agent.run(\"What's 25 * 4?\")\n\nprint(f\"Query: {reasoning.query}\")\nprint(f\"Final response: {reasoning.final_response}\")\nprint(f\"Steps taken: {reasoning.total_steps}\")\n</code></pre>"},{"location":"guide/models/#key-properties","title":"Key Properties","text":"<p>The most important properties you'll use:</p> Property Description <code>query</code> The original question asked <code>final_response</code> The agent's final answer <code>total_steps</code> Number of steps the agent took <code>steps</code> List of all steps, including thinking and tool usage"},{"location":"guide/models/#examining-steps-and-tool-usage","title":"Examining Steps and Tool Usage","text":"<p>Each step in the reasoning process contains information about what the agent was thinking and which tools it used:</p> <pre><code># Loop through each step\nfor step in reasoning.steps:\n    print(f\"\\nStep {step.step_number} thinking:\")\n    print(step.thinking)\n\n    # Show tools used in this step\n    for tool in step.tools:\n        print(f\"Tool: {tool.name}\")\n        print(f\"Inputs: {tool.inputs}\")\n        print(f\"Result: {tool.result}\")\n</code></pre>"},{"location":"guide/models/#practical-example-analyzing-agent-behavior","title":"Practical Example: Analyzing Agent Behavior","text":"<p>Here's how to analyze how your agent solved a problem:</p> <pre><code>from minimalagent import Agent, tool\n\n@tool\ndef search_database(query: str) -&gt; list:\n    \"\"\"Search the database for information.\"\"\"\n    # Simulated database search\n    return [{\"id\": 1, \"result\": f\"Information about {query}\"}]\n\n@tool\ndef format_output(items: list) -&gt; dict:\n    \"\"\"Format items for display.\"\"\"\n    return {\"formatted\": [f\"\u2022 {item['result']}\" for item in items]}\n\n# Create agent with both tools\nagent = Agent(tools=[search_database, format_output])\n\n# Run a query\nresponse, reasoning = agent.run(\"Find information about climate change\")\n\n# Analyze tool usage\ntool_usage = {}\nfor step in reasoning.steps:\n    for tool in step.tools:\n        tool_name = tool.name\n        if tool_name not in tool_usage:\n            tool_usage[tool_name] = 0\n        tool_usage[tool_name] += 1\n\nprint(\"Tool usage summary:\")\nfor tool, count in tool_usage.items():\n    print(f\"- {tool}: used {count} times\")\n\n# Check execution time if timestamps are available\nif hasattr(reasoning, 'start_timestamp') and hasattr(reasoning, 'end_timestamp'):\n    execution_time = reasoning.end_timestamp - reasoning.start_timestamp\n    print(f\"Total execution time: {execution_time} seconds\")\n</code></pre>"},{"location":"guide/models/#working-with-session-history","title":"Working with Session History","text":"<p>When using session management, you can retrieve and analyze past reasoning:</p> <pre><code># Get the most recent reasoning for a session\nlatest_reasoning = agent.get_reasoning(\"user123\")\n\n# Get all reasoning history for a session\nhistory = agent.get_reasoning_history(\"user123\")\n\n# Show evolution of responses\nprint(\"Response history:\")\nfor i, entry in enumerate(history):\n    print(f\"{i+1}: Query: {entry.query}\")\n    print(f\"   Response: {entry.final_response}\")\n\n# Count total tools used across the session\ntotal_tools = 0\nfor entry in history:\n    for step in entry.steps:\n        total_tools += len(step.tools)\n\nprint(f\"Total tools used in session: {total_tools}\")\n</code></pre>"},{"location":"guide/models/#debugging-with-reasoning-data","title":"Debugging with Reasoning Data","text":"<p>The reasoning data is invaluable for debugging agent behavior:</p> <pre><code># Check for tool errors\nfor step in reasoning.steps:\n    for tool in step.tools:\n        if \"error\" in str(tool.result).lower():\n            print(f\"ERROR in tool {tool.name}: {tool.result}\")\n\n# Examine which tools were considered but not used\nfor step in reasoning.steps:\n    thinking = step.thinking.lower()\n    if \"consider\" in thinking and \"tool\" in thinking:\n        print(f\"Step {step.step_number} considered tools: {thinking}\")\n</code></pre> <p>This understanding of reasoning data helps you analyze how your agent works, identify issues, and improve its effectiveness.</p>"},{"location":"guide/sessions/","title":"Session Management","text":"<p>MinimalAgent provides built-in session management to maintain conversation context and track reasoning across multiple interactions.</p>"},{"location":"guide/sessions/#quick-start","title":"Quick Start","text":"<p>Enable session support with just one parameter:</p> <pre><code>agent = Agent(use_session_memory=True)\n\n# First interaction\nresponse1 = agent.run(\"What's the weather in Seattle?\", session_id=\"user123\")\n\n# Later interaction (remembers context)\nresponse2 = agent.run(\"What about tomorrow?\", session_id=\"user123\")\n</code></pre>"},{"location":"guide/sessions/#what-sessions-provide","title":"What Sessions Provide","text":"<ul> <li>Conversation Memory: Agent remembers previous messages and context</li> <li>Reasoning Storage: Track the agent's thinking process over time</li> <li>Persistence: Data stored in DynamoDB with automatic TTL</li> </ul>"},{"location":"guide/sessions/#configuration-options","title":"Configuration Options","text":"<pre><code>agent = Agent(\n    # Basic session settings\n    use_session_memory=True,             # Enable session persistence\n    session_ttl=3600,                    # Session TTL in seconds (default: 1 hour)\n\n    # Advanced settings\n    session_table_name=\"my-sessions\",    # Custom DynamoDB table name\n    real_time_reasoning=True,            # Update reasoning during execution\n    memory_region=\"us-east-1\",           # AWS region for DynamoDB\n)\n</code></pre>"},{"location":"guide/sessions/#retrieving-reasoning-and-tool-invocation-history","title":"Retrieving Reasoning and Tool Invocation History","text":"<p>A key benefit of session management is the ability to retrieve detailed reasoning and tool usage history. This is particularly valuable for debugging, monitoring, or analyzing how the agent performed complex multi-step tasks:</p> <pre><code># Get the most recent reasoning data for a session\nreasoning = agent.get_reasoning(\"user123\")\nprint(f\"Query: {reasoning.query}\")\nprint(f\"Response: {reasoning.final_response}\")\n\n# Examine tool usage from the most recent interaction\nprint(f\"The agent took {reasoning.total_steps} steps to answer\")\nfor step in reasoning.steps:\n    print(f\"\\nStep {step.step_number} thinking: {step.thinking}\")\n\n    # Analyze all tools used in this step\n    for tool in step.tools:\n        print(f\"Tool used: {tool.name}\")\n        print(f\"Tool inputs: {tool.inputs}\")\n        print(f\"Tool result: {tool.result}\")\n\n# Get complete reasoning history across all interactions\nreasoning_history = agent.get_reasoning_history(\"user123\")\nprint(f\"Found {len(reasoning_history)} interactions in this session\")\n\n# Analyze all tool invocations across all interactions\nfor i, interaction in enumerate(reasoning_history):\n    print(f\"\\nInteraction {i+1}: {interaction.query}\")\n    print(f\"Total steps: {interaction.total_steps}\")\n\n    for step in interaction.steps:\n        for tool in step.tools:\n            print(f\"Tool: {tool.name}, Inputs: {tool.inputs}\")\n</code></pre> <p>Note: <code>get_reasoning_history()</code> retrieves reasoning objects with complete tool invocation data, allowing you to track exactly what tools were called, with what parameters, and what results they returned across an entire session.</p>"},{"location":"guide/sessions/#real-time-reasoning-and-tool-tracking","title":"Real-Time Reasoning and Tool Tracking","text":"<p>Enable real-time reasoning to track the agent's thinking process and tool invocations as they happen:</p> <pre><code>agent = Agent(\n    use_session_memory=True,\n    real_time_reasoning=True\n)\n</code></pre> <p>With real-time updates, each thinking step and tool use is written to DynamoDB immediately, enabling:</p> <ol> <li>Live Tool Monitoring: See tools being called in real-time with their parameters and results</li> <li>Complex Task Tracking: Monitor multi-step processes that might take significant time</li> <li>External Monitoring: Build dashboards or monitoring systems by polling the database</li> </ol>"},{"location":"guide/sessions/#example-monitoring-long-running-operations","title":"Example: Monitoring Long-Running Operations","text":"<p>This is especially valuable for applications with long-running operations:</p> <pre><code># In your application\nagent = Agent(\n    tools=[long_running_tool, search_database, complex_analysis],\n    use_session_memory=True,\n    real_time_reasoning=True\n)\n\n# Start a complex operation\nagent.run(\"Analyze the latest data and generate a comprehensive report\", session_id=\"report-task\")\n\n# In a separate monitoring application\nimport time\n\ndef monitor_progress(session_id):\n    while True:\n        reasoning = agent.get_reasoning(session_id)\n\n        # Show completed steps\n        print(f\"Completed {len(reasoning.steps)} of {reasoning.total_steps} steps\")\n\n        # Show tools used so far\n        for step in reasoning.steps:\n            for tool in step.tools:\n                print(f\"Tool used: {tool.name} with inputs: {tool.inputs}\")\n                print(f\"Result: {tool.result}\")\n\n        time.sleep(5)  # Poll every 5 seconds\n</code></pre>"},{"location":"guide/sessions/#session-storage-details","title":"Session Storage Details","text":"<p>Sessions are stored in DynamoDB with: - Automatic table creation - TTL-based expiration - Partition key: <code>messages#{session_id}</code> or <code>reasoning#{session_id}</code> - Sort key: Timestamp</p>"},{"location":"guide/sessions/#dynamodb-table-structure","title":"DynamoDB Table Structure","text":"<p>MinimalAgent uses a single-table design with the following structure:</p> Attribute Type Description <code>pk</code> String Partition key with prefix: <code>messages#{session_id}</code> or <code>reasoning#{session_id}</code> <code>sk</code> Number Sort key using timestamp (Unix epoch) <code>expiration_time</code> Number TTL attribute for automatic deletion <code>messages</code> String JSON string of messages (only in message items) <code>reasoning</code> String JSON string of reasoning data (only in reasoning items)"},{"location":"guide/sessions/#bring-your-own-dynamodb-table","title":"Bring Your Own DynamoDB Table","text":"<p>You can use your own pre-created DynamoDB table instead of having MinimalAgent create one for you. This is useful for:</p> <ul> <li>Infrastructure-as-code deployments</li> <li>Custom resource controls (provisioned capacity, encryption, etc.)</li> <li>Shared tables across multiple applications</li> <li>Custom backup policies</li> </ul> <p>To use your own table, it must follow this schema:</p> <pre><code># AWS SAM/CloudFormation example\nResources:\n  AgentSessionTable:\n    Type: AWS::DynamoDB::Table\n    Properties:\n      TableName: my-custom-session-table\n      BillingMode: PAY_PER_REQUEST  # Or use provisioned capacity\n      AttributeDefinitions:\n        - AttributeName: pk\n          AttributeType: S  # String type\n        - AttributeName: sk\n          AttributeType: N  # Number type\n      KeySchema:\n        - AttributeName: pk\n          KeyType: HASH  # Partition key\n        - AttributeName: sk\n          KeyType: RANGE  # Sort key\n      TimeToLiveSpecification:\n        AttributeName: expiration_time\n        Enabled: true\n</code></pre> <p>Then, tell the agent to use your custom table:</p> <pre><code>agent = Agent(\n    tools=[...],\n    use_session_memory=True,\n    session_table_name=\"my-custom-session-table\",  # Your custom table name\n)\n</code></pre>"},{"location":"guide/sessions/#aws-cloudformationsam-example","title":"AWS CloudFormation/SAM Example","text":"<p>Here's a CloudFormation/SAM template for creating just the DynamoDB table:</p> <pre><code>AWSTemplateFormatVersion: '2010-09-09'\nResources:\n  AgentSessionTable:\n    Type: AWS::DynamoDB::Table\n    Properties:\n      TableName: my-agent-sessions  # Choose your table name\n      BillingMode: PAY_PER_REQUEST  # Or use provisioned capacity\n      AttributeDefinitions:\n        - AttributeName: pk\n          AttributeType: S  # String type for partition key\n        - AttributeName: sk\n          AttributeType: N  # Number type for sort key\n      KeySchema:\n        - AttributeName: pk\n          KeyType: HASH    # Partition key\n        - AttributeName: sk\n          KeyType: RANGE   # Sort key\n      TimeToLiveSpecification:\n        AttributeName: expiration_time\n        Enabled: true\n      # Optional: Add point-in-time recovery\n      PointInTimeRecoverySpecification:\n        PointInTimeRecoveryEnabled: true\n      # Optional: Add tags\n      Tags:\n        - Key: Project\n          Value: MinimalAgent\n\nOutputs:\n  AgentTableName:\n    Description: Session DynamoDB Table Name\n    Value: !Ref AgentSessionTable\n</code></pre> <p>To use this table with MinimalAgent, simply reference its name:</p> <pre><code>from minimalagent import Agent, tool\n\n@tool\ndef example_tool(param: str) -&gt; dict:\n    \"\"\"Example tool functionality.\"\"\"\n    return {\"result\": f\"Processed {param}\"}\n\nagent = Agent(\n    tools=[example_tool],\n    use_session_memory=True,\n    session_table_name=\"my-agent-sessions\"  # Match the table name from CloudFormation\n)\n</code></pre>"},{"location":"guide/sessions/#best-practices","title":"Best Practices","text":"<ol> <li>Use consistent session IDs for related interactions</li> <li>Set appropriate TTL based on expected conversation duration</li> <li>Monitor DynamoDB usage if running at scale</li> </ol>"},{"location":"guide/sessions/#complete-example","title":"Complete Example","text":"<p>Here's a complete example of session management:</p> <pre><code>from minimalagent import Agent, tool\nimport uuid\n\n@tool\ndef answer_question(question: str) -&gt; dict:\n    \"\"\"Answer a simple question.\"\"\"\n    return {\"answer\": f\"The answer to '{question}' is 42.\"}\n\n# Create agent with sessions enabled\nagent = Agent(\n    tools=[answer_question],\n    use_session_memory=True,\n    show_reasoning=True,\n)\n\n# Generate session ID (or use a user ID in a real application)\nsession_id = str(uuid.uuid4())\n\n# First interaction\nresponse1, reasoning1 = agent.run(\n    \"What is the meaning of life?\", \n    session_id=session_id\n)\n\n# Second interaction (referencing the first)\nresponse2, reasoning2 = agent.run(\n    \"Can you elaborate on that?\", \n    session_id=session_id\n)\n\n# Retrieve the reasoning history\nhistory = agent.get_reasoning_history(session_id)\nprint(f\"Found {len(history)} interactions in this session\")\n</code></pre>"},{"location":"guide/tools/","title":"Creating Custom Tools","text":"<p>Tools allow your agent to interact with external systems and APIs. This guide shows you how to define and use custom tools with MinimalAgent.</p> <p>Tip</p> <p>Tools are automatically documented from your docstrings, so write good docstrings!</p>"},{"location":"guide/tools/#basic-tool-definition","title":"Basic Tool Definition","text":"<p>Tools are created using the <code>@tool</code> decorator:</p> <pre><code>from minimalagent import tool\n\n@tool\ndef get_weather(location: str, units: str = \"metric\") -&gt; dict:\n    \"\"\"Get weather information for a location.\n\n    Args:\n        location: City name or location\n        units: Units to use (metric or imperial)\n\n    Returns:\n        Weather data dictionary\n    \"\"\"\n    # Add implementation here\n    return {\"temperature\": 22, \"conditions\": \"sunny\"}\n</code></pre>"},{"location":"guide/tools/#tool-parameters","title":"Tool Parameters","text":"<p>Tools support various parameter types:</p> Type Example Notes <code>str</code> <code>name: str</code> Text values <code>int</code> <code>count: int</code> Integers <code>float</code> <code>temperature: float</code> Decimal numbers <code>bool</code> <code>enabled: bool</code> True/False values <code>list</code> <code>items: list</code> Lists of items <code>dict</code> <code>config: dict</code> Key-value mappings"},{"location":"guide/tools/#adding-tools-to-an-agent","title":"Adding Tools to an Agent","text":"<pre><code># Define your tools\n@tool\ndef tool_a(param: str): \n    \"\"\"A sample tool.\"\"\"\n    return {\"result\": param}\n\n@tool \ndef tool_b(param: int):\n    \"\"\"Another sample tool.\"\"\"\n    return {\"result\": param * 2}\n\n# Add at initialization\nagent = Agent(tools=[tool_a, tool_b])\n\n# Or add later\nagent = Agent()\nagent.add_tools([tool_a, tool_b])\n</code></pre>"},{"location":"guide/tools/#customizing-tool-documentation","title":"Customizing Tool Documentation","text":"<p>You can override the automatic documentation:</p> <pre><code>@tool(\n    name=\"custom_weather\",\n    description=\"Get weather forecast for any location\",\n    param_descriptions={\n        \"location\": \"City name, postal code, or coordinates\",\n        \"units\": \"Unit system: 'metric' (\u00b0C) or 'imperial' (\u00b0F)\"\n    }\n)\ndef get_weather(location: str, units: str = \"metric\"):\n    # Implementation here\n    pass\n</code></pre>"},{"location":"guide/tools/#error-handling-in-tools","title":"Error Handling in Tools","text":"<p>Tools should handle errors gracefully:</p> <pre><code>@tool\ndef divide(a: float, b: float) -&gt; float:\n    \"\"\"Divide two numbers.\n\n    Args:\n        a: Numerator\n        b: Denominator\n\n    Returns:\n        Result of division\n    \"\"\"\n    try:\n        if b == 0:\n            return {\"error\": \"Cannot divide by zero\"}\n        return {\"result\": a / b}\n    except Exception as e:\n        return {\"error\": str(e)}\n</code></pre>"},{"location":"guide/tools/#best-practices","title":"Best Practices","text":"<ol> <li>Clear docstrings: Write clear descriptions and parameter documentation</li> <li>Strong typing: Use type hints for all parameters</li> <li>Return dictionaries: Always return a dictionary with meaningful keys</li> <li>Handle errors: Catch exceptions and return structured error responses</li> <li>Atomic functionality: Each tool should do one thing well</li> </ol>"},{"location":"guide/tools/#example-web-search-tool","title":"Example: Web Search Tool","text":"<pre><code>import requests\n\n@tool\ndef web_search(query: str, results_count: int = 5) -&gt; dict:\n    \"\"\"Search the web for information.\n\n    Args:\n        query: Search query string\n        results_count: Number of results to return (max 10)\n\n    Returns:\n        Dictionary containing search results\n    \"\"\"\n    try:\n        # Limit results to reasonable number\n        results_count = min(max(1, results_count), 10)\n\n        # In a real implementation, you would call a search API\n        # This is a placeholder implementation\n        response = {\n            \"results\": [\n                {\"title\": f\"Result {i+1} for {query}\", \n                 \"snippet\": f\"This is a sample result for {query}\"}\n                for i in range(results_count)\n            ],\n            \"total\": results_count\n        }\n\n        return response\n    except Exception as e:\n        return {\"error\": str(e), \"results\": []}\n</code></pre>"}]}